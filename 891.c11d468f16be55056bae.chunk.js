(()=>{"use strict";class t{constructor(t,e){this.previousStateId=-1,this.previousMove={source:0,target:0},this.moveCount=-1,this.heuristicValue=-1e3,this.id=-1,this.tubeCount=t,this.tubes=e}isGameOver(){return this.isAllTubeComplete()}checkTubesComplete(){for(let t of this.tubes)this.isTubeComplete(t)?t.isComplete=!0:t.isComplete=!1}getTubeById(t){return this.tubes.find((e=>e.id===t))}getCopyState(){const e=[];for(let t of this.tubes){const l=[];for(let e=0;e<t.ballColors.length;e++)l.push(t.ballColors[e]);e.push({id:t.id,tall:t.tall,color:t.color,ballColors:l,isComplete:t.isComplete})}return new t(this.tubeCount,e)}isAllTubeComplete(){for(let t of this.tubes)if(0!==t.ballColors.length&&!this.isTubeComplete(t))return!1;return!0}isTubeComplete(t){if(t.ballColors.length!==t.tall)return!1;for(let e=0;e<t.ballColors.length;e++){if(t.ballColors[e]!==t.color&&0!==t.color)return!1;if(e<t.ballColors.length-1&&t.ballColors[e]!==t.ballColors[e+1])return!1}return!0}}const e=t;self.onmessage=({data:{tubeCount:t,tubes:l}})=>{const s=new class{constructor(t){let l=new class{constructor(){this.states=[]}clearStates(){this.states=[]}createStartState(t){const l=new e(t.tubeCount,t.tubes);l.id=0,l.moveCount=0,this.states.push(l)}addNewState(t,l){const s=new e(t,l);return this.states.push(s),s.checkTubesComplete(),!!s.isGameOver()&&(console.log("you win"),!0)}getCurrentState(){return this.states[this.states.length-1]}isStateExist(t,e){for(let l=e.length-1;l>0;l--)if(this.isTwoTubesSimilar(t.tubes,e[l].tubes))return[!0,e[l]];return[!1,e[0]]}isTwoTubesSimilar(t,e){if(t.length!==e.length)return!1;for(let l=0;l<t.length;l++)if(!this.isTwoTubeHaveSameBallColors(t[l],e[l]))return!1;return!0}isTwoTubeHaveSameBallColors(t,e){if(t.ballColors.length!==e.ballColors.length)return!1;for(let l=0;l<t.ballColors.length;l++)if(t.ballColors[l]!=e.ballColors[l])return!1;return!0}};this.heuristic=new class{constructor(t){this.colorCounts=[0,0,0,0,0,0,0,0,0],this.whiteTubeBallColors=[],this.stateMaxHeap=new class{constructor(){this.values=[]}getValues(){return this.values}setValues(t){this.values=t}insert(t){return 0===this.values.length?(this.values.push(t),!0):(this.values.push(t),this.bubbleUp())}bubbleUp(){let t=this.values.length-1;const e=this.values[t];let l=Math.floor((t-1)/2);for(;l>=0&&this.values[l].heuristicValue<e.heuristicValue;)this.values[t]=this.values[l],this.values[l]=e,t=l,l=Math.floor((t-1)/2);return!0}extractMax(){if(0===this.values.length)return null;let t=this.values[0],e=this.values.pop();return this.values.length>0&&(this.values[0]=e,this.sinkDown()),t}sinkDown(){let t=0,e=0,l=0,s=this.values.length,o=this.values[t],r=0,u=!1;for(;;){e=2*t+1,l=2*t+2,u=!1;let i=null,a=null;if(e<s&&(i=this.values[e],o.heuristicValue<i.heuristicValue&&(r=e,u=!0)),l<s&&(a=this.values[l],(u&&i&&i.heuristicValue<a.heuristicValue||!u&&o.heuristicValue<a.heuristicValue)&&(r=l,u=!0)),!u)return;this.values[t]=this.values[r],this.values[r]=o,t=r}}},this.gameLogic=t}createColorCounts(t){this.colorCounts=[0,0,0,0,0,0,0,0,0];for(let e of t.tubes)for(let t=0;t<e.ballColors.length;t++)this.colorCounts[e.ballColors[t]]+=1}createWhiteTubeBallColor(t){for(let e=1;e<this.colorCounts.length;e++){if(!this.colorCounts[e])continue;let l=!0;for(let s of t.tubes)if(s.color===e){l=!1;break}l&&this.whiteTubeBallColors.push(e)}}solveAllMove(){let t=this.gameLogic.getCurrentState(),e=0,l=null;const s=+new Date;for(;e<3500&&+new Date<s+200;){e+=1;const s=this.getPossibleState(t);for(let e of s){const s=this.gameLogic.isStateExist(e,this.stateMaxHeap.getValues());s[0]?(s[1].heuristicValue<e.heuristicValue||s[1].heuristicValue===e.heuristicValue&&s[1].moveCount>e.moveCount)&&(s[1].heuristicValue=e.heuristicValue,s[1].moveCount=e.moveCount,s[1].previousStateId=e.previousStateId,s[1].previousMove=e.previousMove):e.heuristicValue-t.heuristicValue>-15&&(l?e.moveCount<l.moveCount&&this.stateMaxHeap.insert(e):this.stateMaxHeap.insert(e))}let o=this.stateMaxHeap.extractMax();if(!o)break;if(l)for(;o.moveCount>=l.moveCount&&(o=this.stateMaxHeap.extractMax(),o););if(!o)break;if(o.isGameOver()&&((null===l||o.moveCount<l.moveCount)&&(l=o),o=this.stateMaxHeap.extractMax(),!o))break;t=o,o.id=this.gameLogic.states.length,this.gameLogic.states.push(o)}let o=[];if(l)for(;-1!==l.previousStateId;)o.push(l.previousMove),l=this.gameLogic.states[l.previousStateId];else console.error("No best goal, something error");return{moves:o.reverse()}}calculateHeuristic(t){let e=0;const l=t.tubes;for(let t of l)if(0===t.color){const l=this.calculateHeuristicArrayWhiteTube(t);e+=this.sumOfArray(l)}else{const l=this.calculateHeuristicArrayColorTube(t);e+=this.sumOfArray(l)}return e}getAllPossibleMove(t){let e=t.tubes,l=[];for(let t=0;t<e.length;t++)if(e[t].ballColors.length!==e[t].tall)for(let s=0;s<e.length;s++)t==s||e[s].ballColors.length<=0||l.push({source:s,target:t});return l}getPossibleState(t){let e=[],l=this.getAllPossibleMove(t);for(let s of l){const l=this.getNewState(t,s.source,s.target);l.previousMove=s,l.previousStateId=t.id,l.moveCount=t.moveCount+1;const o=this.calculateHeuristic(l)-5*l.moveCount;l.heuristicValue=o;const r=this.gameLogic.isStateExist(l,this.gameLogic.states);r[0]&&(r[1].heuristicValue>l.heuristicValue||r[1].heuristicValue===l.heuristicValue&&r[1].moveCount<=l.moveCount)||e.push(l)}return e}calculateHeuristicArrayWhiteTube(t){let e=[];if(0===t.ballColors.length)e.push(0);else{let l=!1;this.colorCounts[t.ballColors[0]]===t.tall?(this.whiteTubeBallColors.includes(t.ballColors[0])?e.push(5+t.tall):e.push(2+t.tall),l=!0):e.push(-(1+t.tall));let s=1;for(;s<t.ballColors.length&&t.ballColors[s]===t.ballColors[s-1]&&t.tall===this.colorCounts[t.ballColors[s]];)this.whiteTubeBallColors.includes(t.ballColors[s])?e.push(5+t.tall+s):e.push(2+t.tall+s),s+=1,l=!0;if(s<t.ballColors.length){l?e.push(-5):e.push(-2);for(let l=s+1;l<t.ballColors.length;l++)e.push(-2)}}return t.isComplete&&t.tall===this.colorCounts[t.ballColors[0]]&&e.push(3+t.tall),e}calculateHeuristicArrayColorTube(t){let e=[];if(0===t.ballColors.length)e.push(0);else{let l=!1;this.colorCounts[t.ballColors[0]]===t.tall&&t.ballColors[0]===t.color?e.push(7+t.tall):e.push(-(5+t.tall));let s=1;for(;s<t.ballColors.length&&t.ballColors[s]===t.ballColors[s-1]&&t.ballColors[s]===t.color&&t.tall===this.colorCounts[t.color];)e.push(7+t.tall+s),s+=1,l=!0;if(s<t.ballColors.length){l?e.push(-5):e.push(-2);for(let l=s+1;l<t.ballColors.length;l++)e.push(-2)}}return t.isComplete&&t.tall===this.colorCounts[t.color]&&e.push(5+t.tall),e}sumOfArray(t){let e=0;for(let l=0;l<t.length;l++)e+=t[l];return e}getNewState(t,e,l){const s=t.getCopyState(),o=s.getTubeById(e),r=s.getTubeById(l),u=o.ballColors.pop();return r.ballColors.push(u),s.checkTubesComplete(),s}}(l),l.clearStates(),l.createStartState(t);const s=this.heuristic.gameLogic.getCurrentState();s.checkTubesComplete(),this.heuristic.createColorCounts(s),this.heuristic.createWhiteTubeBallColor(s),s.heuristicValue=this.heuristic.calculateHeuristic(s)}solveAllMoveOptimize(){return this.heuristic.solveAllMove()}}({tubeCount:t,tubes:l}).solveAllMoveOptimize().moves;self.postMessage({answer:s}),close()}})();